# <img src="../books.svg" alt="Stack of red books with a graduation cap on top, symbolizing education and achievement, set against a plain background" width="30" height="20" /> Unit Testing Spark Jobs

## <img src="../notes.svg" alt="Orange pencil lying diagonally on a white sheet of paper, representing note taking and documentation, with a clean and organized appearance" width="20" height="15" /> Importance, Challenges, and Leadership Perspectives Lecture

| Concept                | Notes            |
|---------------------|------------------|
| **Catching Quality Bugs**  | - Where can you catch quality bugs? <br> &emsp;• In development <br> &emsp;&emsp;• Best case <br> &emsp;• In production, but not showing up in tables <br> &emsp;&emsp;• Still good <br> &emsp;• In production, in production tables<br> &emsp;&emsp;• Terrible and destroys trust <br>- Ways bugs show up in production: <br> &emsp;• When you are doing write, audit, and/or publish<br> &emsp;&emsp;• You write to a staging table<br> &emsp;&emsp;• run your audits<br> &emsp;&emsp;• your audits fail<br> &emsp;&emsp;• you don't end up publishing because your audits fail<br> &emsp;&emsp;• then you have to troubleshoot <br> &emsp;• This is something you want to minimize doing because it can lead to false positives <br> &emsp;• These types of data quality checks are more expensive than the ones that happen in development |
| **Catching Bugs In Development**  | - How do you catch bugs in development? <br> &emsp;• Unit tests and integration tests of your pipelines! <br> &emsp;• If you have UDFs or a specific function that does a lookup or something, you want to write tests for each individual function <br> &emsp;• ***ESPECIALLY AND CRITICALLY IF THAT FUNCTION CALLS A DIFFERENT LIBRARY***<br> &emsp;&emsp;• If you depend on someone else's code and they change that code, breaking your test, *they have to fix your test before they can merge*<br> &emsp;&emsp;• **Unit tests allow you safely depend on other people's code** <br> &emsp;• Have a linter <br> &emsp;&emsp;• Linting enforces coding standards<br> &emsp;&emsp;&emsp;• Forces everyone to code the same wa<br> &emsp;&emsp;• You may not be able to catch a bug this way, but it makes your code more readable, which can make it more likely to catch bugs |
| **Catching Bugs In Production**  | - How do you catch bugs in production? <br> &emsp;• Use the write-audit-publish pattern! <br> &emsp;&emsp;• Write your data to a test table/staging table that has the same schema as your production table <br> &emsp;&emsp;• Run your quality checks <br> &emsp;&emsp;• If they pass, then you move the staging data into production|
| **Worst-Case Scenarios**  | - Data analyst finds bugs in production and tells you about it<br>- Ruins trust<br>- Ruins mood <br>- Nobody wins <br>- Data quality bugs are not caught and then bad decisions are made off of the bad data<br> &emsp;• Absolute worst case scenario! |
| **Software Engineering Has Higher Quality Standards Than Data Engineering!**  | - Why? <br> &emsp;• Risks <br> &emsp;&emsp;• Server going down is a bigger impact than a pipeline delay<br> &emsp;&emsp;• Frontend being non-responsive stops the business, too<br> &emsp;&emsp;• Striving for higher quality standards should always be done!<br> &emsp;• Maturation<br> &emsp;&emsp;• Software engineering is a more mature field<br> &emsp;&emsp;• Test-driven development and behavior-driven development are new in data engineering <br> &emsp;• Talent <br> &emsp;&emsp;• Data engineers come from a much more diverse background than SWEs|
| **How Data Engineering Will Become Risker**  | - Data delays impact machine learning <br> &emsp;• Every day that notification ML was behind resulted in a ~10% drop in effectiveness and click through rates <br>- Data quality bugs impact experimentation<br> &emsp;• If the bugs impact A/B test results, the people interpreting it may be getting the wrong idea<br>- As trust rises in data, risk rises too<br> It is good practice when building a pipeline to ask yourself **what are the consequences of this breaking and how do I mitigate that?** <br>- ***You can build lasting, high-quality datasets AND answer questions quickly!!!***|
| **The Tradeoff Between Business Velocity and Sustainability**  | - Business wants answers fast <br>- Engineers don't want to die from a mountain of tech debt <br>- Who wins? <br>&emsp;• Depends on the strength of your engineering leaders and how much you push back<br>- **Don't cut corners to go faster in a more sustainable fashion!** |
| **Data Engineering Capability Standards Will Increase Over Time**  | - Latency <br> &emsp;• Solved with streaming pipelines and microbatch pipelines<br> &emsp;&emsp;• Streaming pipelines run 24/7, which increases the chance something can go wrong<br>- Quality <br> &emsp;• Solved with best practices and frameworks like Great Expectations or Amazon DQ<br>- Completeness <br> &emsp;• Solved with communication with domain experts<br>- Ease-of-access and usability<br> &emsp;• Solved by data products and proper data modeling |
| **Adopting a Software Engineering Mindset with Data Engineering**  | - ***Code is 90% read by humans and 10% executed by machines*** <br> &emsp;• Write code that is readable to help with troubleshooting!<br>- Silent failures are your enemy <br>- Loud failures are your friend<br> &emsp;• Fail the pipeline when bad data is introduced<br> &emsp;&emsp;• Throw/raise an exception <br> &emsp;&emsp;• You can make custom exceptions as well<br> &emsp;• Loud failures are accomplished by testing and CI/CD<br>- DRY code and YAGNI principles<br> &emsp;• **DRY = Don't Repeat Yourself** <br> &emsp;• **YAGNI = You Aren't Gonna Need It**<br> &emsp;&emsp;• Build things out as you need them<br> &emsp;• SQL and DRY are very combative<br>- Design documents are your friend <br>- Care about efficiency <br> &emsp;• Data structures and algorithms<br> &emsp;• Understanding `JOIN` and shuffle|
| **Should Data Engineers Learn Software Engineering Best Practices?**  | - Short answer, YES!<br>- LLMs and other things will make the analytics and SQL layer of data engineering job more susceptible to automation<br>-If you don't want to learn these things <br> &emsp;• Go into analytics engineering |

## <img src="../question-and-answer.svg" alt="Two speech bubbles, one with a large letter Q and the other with a large letter A, representing a question and answer exchange in a friendly and approachable style" width="35" height="28" /> Cues

- What is one of the primary benefits of catching bugs during development in Spark pipelines?
- Why is it recommended to catch bugs during the development phase of data pipelines?
- What are the consequences when a data quality bug bypasses quality checks and reaches production?
- What mindset should data engineers adopt to improve pipeline quality?
- Why might software engineering have higher quality standards than data engineering?
- How can unit and integration tests provide safety when depending on external libraries in Spark jobs?
- What is a significant benefit of unit testing according to the lecture?
- Which testing method is emphasized to improve the coding standards of a team?
- How does the adoption of software engineering best practices benefit a data engineer?
- What is the suggested course of action if a data engineer is uninterested in software engineering fundamentals?

---

## <img src="../summary.svg" alt="Rolled parchment scroll with visible lines, symbolizing a summary or conclusion, placed on a neutral background" width="30" height="18" /> Summary

Catching bugs during development allows for a smoother development process. Issues that are resolved early prevent disruptions in production and help maintain data quality, reducing errors visible to end-users and mitigating potential issues in live environments. When quality issues are discovered in production, it can cause stakeholders to question the data's integrity, leading to a loss of trust and potentially impacting decision-making processes.

Software engineering has been established longer, allowing for more developed quality standards. By embracing software engineering principles like qriting readable, test-driven code, data engineers can raise the quality of their pipelines and ensure they are robust and maintainable. Additionally, software failure usually have more immediate and apparent consequences, necessitating strict quality measures.

Unit and integration tests act as a safeguard when relying on external libraries, as any changes that negatively impact the code will fail tests, preventing integration until corrected. Unit testing ensures that changes in third-party libraries don't break your code by revealing dependencies that need updating, thereby maintaining compatibility. Linting is a method highlighted within the lecture to enforce coding standards and readability, which makes it easier to spot bugs and maintain a uniform codebase.

By adopting these best practices, data engineers build a robust skillset that opens opportunities in software engineering, increasing career versitility. The lecture suggests transitioning to analytics engineering if one prefers not to engage with software engineering fundamentals, as it requires less of these skills.
