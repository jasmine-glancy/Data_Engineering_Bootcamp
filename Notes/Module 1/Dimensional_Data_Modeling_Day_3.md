# <img src="../books.svg" alt="Stack of red books with a graduation cap on top, symbolizing education and achievement, set against a plain background" width="30" height="20" /> Dimensional Data Modeling

## <img src="../notes.svg" alt="Orange pencil lying diagonally on a white sheet of paper, representing note taking and documentation, with a clean and organized appearance" width="20" height="15" /> Graph Data Modeling Day 3 Lecture

| Concept                | Notes            |
|---------------------|------------------|
| **Graph Data Modeling**  | - More *relationship* focused and less entity focused <br>  &emsp;• Looks at how things are connected <br>  &emsp;• Flexible schema |
| **Flexible Data Types**  | - `MAP` is an example of a flexible data type <br>  &emsp;• `STRUCT` is not flexible<br>  &emsp;• `ARRAY` is semi-flexible |
| **Additive Dimensions**  | - Are not double-counted<br>- If you take the subtotals of everything, and add them together to get a grand total<br>  &emsp;• Example: Age is additive <br>  &emsp;&emsp;• The population is equal to 20 year olds + 30 year olds + 40 year olds...<br>  &emsp;• Application interface is NOT additive<br>  &emsp;&emsp;• The number of active users!= # of users on web + # of users on Android +# of users on iphone<br>  &emsp;• Counting drivers by cars is NOT additive<br>  &emsp;&emsp;• The number of Honda drivers != # of Civic drivers + # of Corolla driver + # of accord drivers <br>- Can an entity have 2 dimensional values at the same time over some time frame?<br>- **A dimension is additive over a specific window of time, if and only if, the grain of data over that window can only ever be one value at a time!** <br><br> Always think about how your dimensions interact with time!|
| **How Does Additivity Help?**  | - You don't need to use `COUNT(DISTINCT)` on preaggregated dimensions<br>- Remember non-additive dimensions are usually only non-additive with respect to `COUNT` aggregagtions, but not `SUM` aggregations! <br>  &emsp;• If the user can be 2 or more of these at the same time during any given day, then it's not additive |
| **Enums**  | - Are great for low-to-medium cardinality <br> &emsp;• But there is a limit!<br>- Country is a great example of where Enums start to struggle<br> &emsp;• There's too many countries to limit them via an Enum<br> **Why should you use enums?**<br> &emsp;• Built in data quality<br> &emsp;&emsp;• If you get a value that doesn't fit in the enum, the pipeline fails because the value doesn't exist<br> &emsp;• Built in static fields<br> &emsp;• Built in documentation <br>- Should ideally be used for 50 or less possible values <br>- Enumerations make amazing subpartitions because <br> &emsp;• You have an exhaustive list<br> &emsp;• They chunk up the big data problem into managable pieces <br>- If you are looking at a bunch of data sets and wondering "wow, how do I manage this?", group those data sets into an enumerated group!|
| **How Do Enums Work?**  | ![Enum Graph](enum.png)<br>- N number of sources <br>- Enums get shared with the source functions <br> &emsp;• The source functions map the data to a shared schema via the Shared Logic ETL<br> &emsp;&emsp;• Shared Logic ETL calls the source function <br> &emsp;&emsp;• Shared Logic ETL maps it over into the shared schema <br>- The little book of Enums also has the data quality checks for that enumerated value<br> &emsp;• Even if you have a shared schema, you can have customized data quality checks on each partition depending on whatever is in the little book <br>- After the data quality checks pass, then you have the subpartitioned output<br> &emsp;• This subpartitioned output will have a date partition and a subpartition with the enumerated value
| **How the Little Book of Enums is Generated**  | - Usually an enumeration defined in Python or Scala <br> &emsp;• A job that turns the enumerated list into a tiny table enum values<br> &emsp;• This is how it can be shared between DQ checks and source functions<br> &emsp;• In the source functions, you pass it as Python<br> &emsp;• In the DQ Checks, you pass it as a table JOIN to get your thresholds for week over week, month over month, etc <br>- Check out the [Little Book of Pipelines](https://github.com/EcZachly/little-book-of-pipelines), an open-source GitHub resource for more|
| **When Is a Little Book of Enums Useful?**  | - Whenever you have tons of sources mapping to a shared schema <br> &emsp;• AirBnB <br> &emsp;&emsp;• Unit Econimics (fees, coupons, deposits, insurance, infrastructure cost, taxes, etc)<br> &emsp;• Netflix<br> &emsp;&emsp;• Infrastructure Graph (applications, databases, servers, code bases, CI/CD, jobs, etc)<br> &emsp;• Facebook<br> &emsp;&emsp;• Family of Apps (oculus, Instagram, Facebook, Messenger, WhatsApp, Threads, etc)|
| **Modeling Data From Disparate Sources Into Shared Schemas**  | - This can be done with a flexible schema <br> &emsp;• Don't bring in every column from every table <br> &emsp;• Leverages map data types <br> &emsp;• Overlaps with graph databases <br> &emsp;• If you need to add more things, put it in the map <br> &emsp;&emsp;• There is a limit, but it's high<br><br> &emsp;• ***Benefits***<br> &emsp;&emsp;• You don't have to run `ALTER TABLE` commands <br> &emsp;&emsp;• You can manage a lot more columns <br> &emsp;&emsp;• Your schemas don't have a ton of `NULL` columns<br> &emsp;&emsp;• `other_properties` column is pretty awesome for rarely-used-but-needed columns<br> &emsp;• ***Drawbacks***<br> &emsp;&emsp;• Compression is usually worse<br> &emsp;&emsp;&emsp;• Maps are pretty large and don't compress well<br> &emsp;&emsp;&emsp;• Especially if you use JSON<br> &emsp;&emsp;• Readability, queryability|
| **How Graph Data Modeling is Different**  | - Because graph modeling is *relationship* focused and *not entity focused*, you can do a very poor job at modeling the entries<br> &emsp;• ***Usually the model looks like:*** <br> &emsp;&emsp;• Identifier: STRING <br> &emsp;&emsp;•Type: STRING<br> &emsp;&emsp;• Properties: MAP<STRING, STRING><br> &emsp;•If you can remember this schema, your graph data modeling skills are mastered because they all have this flexible schema<br>- We care about the **relationships**, not the entities themselves.<br> &emsp;• Less about how things *are* and more about *how they are connected* <br><br> ![Graph Diagram](graphdiagram.png)<br>- ***Relationships are modeled a bit more in depth:***<br> &emsp;• Usually the model looks like:<br> &emsp;&emsp;• subject_identifier STRING<br> &emsp;&emsp;• subject_type: VERTEX_TYPE<br> &emsp;&emsp;• object_identifier: STRING<br> &emsp;&emsp;• object_type: VERTEX_TYPE<br> &emsp;&emsp;• edge_type: EDGE_TYPE<br> &emsp;&emsp;• properties: MAP<STRING, STRING> <br> &emsp;• `EDGE TYPE` is almost always a verb (is, a, plays, with, has)<br> &emsp;&emsp;• A simple word that connects things |

## <img src="../question-and-answer.svg" alt="Two speech bubbles, one with a large letter Q and the other with a large letter A, representing a question and answer exchange in a friendly and approachable style" width="35" height="28" /> Cues

- What is a primary focus of graph data modeling compared to dimensional or relational data modeling?
- How is schema flexibility in graph data modeling typically described?
- What is the challenge in non-additive dimensions when aggregating data?
- What is the challenge in non-additive dimensions when aggregating data?
- When should enums be used according to the lecture?
- What comprises the schema of an edge in a graph database?

---

## <img src="../summary.svg" alt="Rolled parchment scroll with visible lines, symbolizing a summary or conclusion, placed on a neutral background" width="30" height="18" /> Summary

Graph data modeling is an ideal way to understand how different entities are connected. This is because they are more relationship focused than entity focused. The schema is highly flexible, which allos properties to be easily added to vertices or edges without strict constraints.

With graph data modeling, it's important to think about how your dimensions interact with time. If you are able to add all the sub-totals of a dimension up, you are left with an additive dimension. If an entity can have two dimensional values at the same time over some time frame, this is a non-additive dimension. In non-additive dimensions, partial aggregations can lead to incorrect totals due to over-counting. Therefore, it's necessary to carefully handle distinct counts.

Enums are effective when there are fewer than 50 possible values, which allows built-in data quality and documentation benefits. Edges in a graph database have schema that includes subject and object identifiers and types, edge type, and properties. The focus of the edge's schema is to focus on relationships between notes. 